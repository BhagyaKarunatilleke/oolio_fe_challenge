import 'package:hive_flutter/hive_flutter.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../constants/storage_keys.dart';
import '../../shared/models/sync_status.dart';
import '../../features/sync/data/models/sync_operation.dart';

class LocalStorageService {
  static LocalStorageService? _instance;
  static LocalStorageService get instance => _instance ??= LocalStorageService._();
  
  LocalStorageService._();

  late Box<dynamic> _productsBox;
  late Box<dynamic> _ordersBox;
  late Box<dynamic> _syncQueueBox;
  late Box<dynamic> _conflictsBox;
  late Box<dynamic> _syncStatusBox;
  late SharedPreferences _prefs;

  bool _isInitialized = false;

  Future<void> initialize() async {
    if (_isInitialized) return;

    await Hive.initFlutter();
    
    // Register adapters
    _registerAdapters();

    // Open boxes
    _productsBox = await Hive.openBox(StorageKeys.productsBox);
    _ordersBox = await Hive.openBox(StorageKeys.ordersBox);
    _syncQueueBox = await Hive.openBox(StorageKeys.syncQueueBox);
    _conflictsBox = await Hive.openBox(StorageKeys.conflictsBox);
    _syncStatusBox = await Hive.openBox(StorageKeys.syncStatusBox);

    // Initialize SharedPreferences
    _prefs = await SharedPreferences.getInstance();

    _isInitialized = true;
  }

  void _registerAdapters() {
    // Register all Hive adapters here
    // Note: These will be generated by build_runner
    // The adapters are automatically registered when the .g.dart files are imported
  }

  // Generic CRUD operations
  Future<void> save<T>(String boxName, T entity) async {
    final box = _getBox(boxName);
    // For entities with id field, use it as key
    final id = (entity as dynamic).id;
    await box.put(id, entity);
  }

  Future<T?> get<T>(String boxName, String id) async {
    final box = _getBox(boxName);
    return box.get(id) as T?;
  }

  Future<List<T>> getAll<T>(String boxName) async {
    final box = _getBox(boxName);
    return box.values.cast<T>().toList();
  }

  Future<void> delete(String boxName, String id) async {
    final box = _getBox(boxName);
    await box.delete(id);
  }

  Future<void> deleteAll(String boxName) async {
    final box = _getBox(boxName);
    await box.clear();
  }

  // Sync-specific operations for entities with syncStatus
  Future<List<T>> getPendingSync<T>(String boxName) async {
    final box = _getBox(boxName);
    return box.values
        .cast<T>()
        .where((entity) => (entity as dynamic).syncStatus == SyncStatus.pending)
        .toList();
  }

  Future<List<T>> getFailedSync<T>(String boxName) async {
    final box = _getBox(boxName);
    return box.values
        .cast<T>()
        .where((entity) => (entity as dynamic).syncStatus == SyncStatus.failed)
        .toList();
  }

  Future<List<T>> getConflictedSync<T>(String boxName) async {
    final box = _getBox(boxName);
    return box.values
        .cast<T>()
        .where((entity) => (entity as dynamic).syncStatus == SyncStatus.conflicted)
        .toList();
  }

  // Transaction support
  Future<void> executeTransaction(
      List<TransactionOperation> operations) async {
    // For now, we'll execute operations sequentially
    // In a real implementation, you might want to use a proper transaction system
    try {
      for (final operation in operations) {
        await _executeOperation(operation);
      }
    } catch (e) {
      // In a real implementation, you would rollback here
      rethrow;
    }
  }

  Future<void> _executeOperation(TransactionOperation operation) async {
    final box = _getBox(operation.entityType);
    
    switch (operation.operation) {
      case SyncOperation.create:
      case SyncOperation.update:
        await box.put(operation.entityId, operation.data);
        break;
      case SyncOperation.delete:
        await box.delete(operation.entityId);
        break;
    }
  }

  // Utility methods
  Box<dynamic> _getBox(String boxName) {
    switch (boxName) {
      case StorageKeys.productsBox:
        return _productsBox;
      case StorageKeys.ordersBox:
        return _ordersBox;
      case StorageKeys.syncQueueBox:
        return _syncQueueBox;
      case StorageKeys.conflictsBox:
        return _conflictsBox;
      case StorageKeys.syncStatusBox:
        return _syncStatusBox;
      default:
        throw ArgumentError('Unknown box name: $boxName');
    }
  }

  // SharedPreferences methods
  Future<void> setString(String key, String value) async {
    await _prefs.setString(key, value);
  }

  String? getString(String key) {
    return _prefs.getString(key);
  }

  Future<void> setBool(String key, bool value) async {
    await _prefs.setBool(key, value);
  }

  bool? getBool(String key) {
    return _prefs.getBool(key);
  }

  Future<void> setInt(String key, int value) async {
    await _prefs.setInt(key, value);
  }

  int? getInt(String key) {
    return _prefs.getInt(key);
  }

  Future<void> setDateTime(String key, DateTime value) async {
    await _prefs.setString(key, value.toIso8601String());
  }

  DateTime? getDateTime(String key) {
    final value = _prefs.getString(key);
    return value != null ? DateTime.parse(value) : null;
  }

  // Cleanup
  Future<void> dispose() async {
    await _productsBox.close();
    await _ordersBox.close();
    await _syncQueueBox.close();
    await _conflictsBox.close();
    await _syncStatusBox.close();
    _isInitialized = false;
  }
}

// Transaction operation model
class TransactionOperation {
  final String entityType;
  final String entityId;
  final SyncOperation operation;
  final Map<String, dynamic> data;

  TransactionOperation({
    required this.entityType,
    required this.entityId,
    required this.operation,
    required this.data,
  });
}
